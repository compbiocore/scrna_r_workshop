# Advanced Topics in scRNAseq 
What we'll cover:
    - Working with multimodal data
    - Controlling for Type I error in estimated clusters with clusterpval
    - Classifying cell types with a reference atlas with TransferAnchors from Seurat    
    - Gene set enrichment analysis with fgsea
    - Joint estimation of differential expression and gene set enrichment with iDEA      
    
### Working with multimodal data
Multimodal scRNA-seq is a quickly evolving field that allows simultaneous measurements of multiple types of information from a given cell. We won't discuss these exhaustively, but will briefly cover CITE-seq, cell hashing, and the 10x ATAC + GEX Multiome kits.

**CITE-seq and Cell Hashing**
This workshop will touch on working with CITE-seq data, which simultaneously profiles cell surface protein and gene expression levels (https://www.nature.com/articles/nmeth.4380 and https://cite-seq.com/). 

![sc flow](src/citeseq_flow.png)
Similar to the standard set-up for 10x gene expression preps, CITE-seq starts with a cell and a barcoded bead encapsulated in a droplet. However, before the encapsulation step, oligo-barcoded antibodies are added to the cells and will bind to the cell surface proteins. 
   
![sc flow](src/citeseq_str.png)

The oligo-tagged antibodies look like the above figure. Once the cells are in a droplet with a bead, the bead dissolves and the poly(dT) primer will allow amplification of both the poly-adenylated mRNA and the antibody barcode library. The two cDNA pools are size-separated before library prep continues, so you'll get back a quantitative gene expression and quantitative antibody derived tag (ADT) library. The authors of CITE-seq state: "We have successfully used ~125 antibodies and do not foresee any reason why this number can’t be further increased", but as always this is dependent on the quality of your antibodies. CellRanger/10X don't formally support CITE-seq for their own reasons and suggest you contact New York Genome Center/https://cite-seq.com/ or BioLegend for help (https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/using/feature-bc-analysis#feature-ref).

![sc flow](src/cellhashing.png)

Cell hashing is similar to CITE-seq, but the goal is to pool multiple samples per 10x run rather than to quantify cell surface proteins. It still uses oligo-tagged antibodies, but they target a smaller subset of cell surface proteins that are ubiquitously expressed and each sample has a unique oligo sequence that can be used to bin each cell back to the sample it originated from. A cell hashing experiment would result in an HTO library (HashTag Oligo) and a gene expression library.

![sc flow](src/totalseq.png){height=400px width=300px} 

BioLegend cells TotalSeq kits to run cell hashing experiments. TotalSeq-B and TotalSeq-C are supported by 10x and they use Capture Sequence 1 or the Template Switch Oligo as the capture sequence. Like CITE-seq, TotalSeq-A uses the Poly(dT) capture sequence and is not supported by 10x and they suggest you contact New York Genome Center/https://cite-seq.com/ or BioLegend for help.

**10X Multiome kit**

![sc flow](src/atac_bead.png){height=175px width=500px} 

The 10x Multiome ATAC + GEX kits let you look at areas of open chromatin and gene expression at the same time. They use a similar approach to the others described above, where a gel bead has primers/capture sequences for gene expression libraries and ATAC-seq libraries. The general workflow starts with isolating single nuclei (rather than single cells). Then, single nuclei are treated with a transposase that fragments DNA in open chromatin areas and adds adapter sequences to the ends of the fragments. The gel beads contain the usual Poly(dT) to amplify poly-adenylated mRNA and also a 'Spacer' sequence that acts as a capture sequence for the ATAC-seq libraries that sequence areas of open chromatin. 

###############################################

Let's try working with some multimodal data in Seurat.

As in the previous workshop, we'll need to set the `.libPaths()`, set a seed and `future.globals.maxSize`, and import the libraries.

```{r}
.libPaths(c('/usr/local/lib/R/site-library', '/usr/local/lib/R/library'))
set.seed(61)
options(future.globals.maxSize = 4000 * 1024^5)
library(RColorBrewer)
library(Seurat)
library(patchwork)
library(ggplot2)
library(dplyr)
library(hdf5r)
library(stringr)
library(biomaRt)
library(kableExtra)
library(knitr)
library(pdftools)
library(viridis)
library(openxlsx)
library(SeuratDisk)
library(SeuratData)
library(ComplexHeatmap)
library(plotly)
library(iDEA)
library(fgsea)
library(clusterpval)
library('pbmc3k.SeuratData')
library('cbmc.SeuratData')
library('ifnb.SeuratData')
library('panc8.SeuratData')
data("pbmc3k")
data("cbmc")
data("ifnb")
data("panc8")


```

We'll work with the `cbmc` data for this section of the workshop, which is 8,617 cord blood mononuclear cells (CBMCs), produced with CITE-seq 
```{r}
cbmc
```

- This data has already come with the ADT assay added, which you'd have to add on your own if you were working with your own data.
- To do that, you'd use the `Read10x` or `Read10X_h5` functions to import your GE and ADT libraries. 
- At this point you might want to do some filtering on your data to get back cell barcodes where you've got RNA and ADT data.
- That might look like this (I've commented out the code here since it won't actually run, you can see the Seurat vignette here https://satijalab.org/seurat/articles/hashing_vignette.html, which shows how to demultiplex cell hashing data):

First, read in the 10X data
```{r}
#pbmc.ge <- Read10X("/pbmc_ge/outs/filtered_feature_bc_matrix")
#pbmc.adt <- Read10X("/pbmc_adt/outs/filtered_feature_bc_matrix")
```

Then, find the column names (which are cells) where you have data from both assays
```{r}
#joint.bcs <- intersect(colnames(pbmc.ge), colnames(pbmc.adt))
```

Then subset counts by joint cell barcodes
```{r}
#pbmc.ge <- pbmc.ge[, joint.bcs]
#pbmc.adt <- pbmc.adt[, joint.bcs]
```

Then you'd use the `CreateSeuratObject` function with the gene expression matrix.
```{r}
#pbmc_seurat <- CreateSeuratObject(counts = pbmc.ge)
```

Then add the ADT data as an assay:
```{r}
#pbmc_seurat[["ADT"]] <- CreateAssayObject(counts = pbmc.adt)
```

Let's look at the multimodal seurat object assays:    

For the RNA assay, cells are columns and rows are genes.
```{r}
head(rownames(cbmc@assays$RNA))
head(colnames(cbmc@assays$RNA))
```

For ADT assay, cells columns and rows are cell surface proteins.
```{r}
rownames(cbmc@assays$ADT)
head(colnames(cbmc@assays$ADT))
```

Make sure the RNA is the default assay:
```{r}
DefaultAssay(cbmc) <- 'RNA'
```

We can run through the standard data normalization, clustering, and dimension reduction pipeline, skipping the QC filtering since this is a curated dataset.
```{r}
# perform visualization and clustering steps
cbmc <- SCTransform(cbmc,verbose=FALSE,return.only.var.genes = FALSE)
cbmc <- RunPCA(cbmc, verbose = FALSE)
cbmc <- FindNeighbors(cbmc, dims = 1:10)
cbmc <- FindClusters(cbmc)
cbmc <- RunUMAP(cbmc, dims = 1:10)
cbmc <- RunTSNE(cbmc, tsne.method = "FIt-SNE", seed.use=61)
DimPlot(cbmc, label = TRUE)
```

We'll also normalize the CITE-seq ADT dat. We'll use a CLR or centered log ratio transformation. 
```{r}
DefaultAssay(cbmc) <- "ADT"
cbmc <- NormalizeData(cbmc, normalization.method = "CLR")
```

Then we can visualize our data -- let's look at the CD19 RNA and Protein expression:
```{r}
DefaultAssay(cbmc) <- "RNA"
p1 <- FeaturePlot(cbmc, 
            features = "CD19", 
            reduction = 'umap',  
            order = T) &
    theme(legend.position = "right") &
    scale_colour_gradient(low = '#67a9cf', high = '#ef8a62') &
    labs(title = "RNA - CD19")

DefaultAssay(cbmc) <- "ADT"
p2 <- FeaturePlot(cbmc, 
            features = "CD19", 
            reduction = 'umap',  
            order = T) &
    theme(legend.position = "right") &
    scale_colour_gradient(low = '#67a9cf', high = '#ef8a62') &
    labs(title = "ADT - CD19")


p1 | p2
```

We can leverage the multimodal data to find protein and RNA markers

First, which clusters of cells are expressing CD19 on their cell surfaces?
```{r}
VlnPlot(cbmc, "CD19", assay = "ADT")
```

Let's look at the ADT markers for cluster 10. You can use the same `FindMarkers` functions that are used for RNA markers.
```{r}
adt_markers <- FindMarkers(cbmc, ident.1 = 10, assay = "ADT")
rna_markers <- FindMarkers(cbmc, ident.1 = 10, assay = "RNA")
```

```{r}
head(rna_markers)
head(adt_markers)
```

Let's clear the `cbmc` data before we move on.

```{r}
rm(cbmc)
```


### Controlling for Type I error in estimated clusters with clusterpval
The first part of this workshop ran through how to use Seurat to cluster the cells. The first step is running a PCA (`RunPCA`), which then gets used as the input for the `FindNeighbors` function. `FindNeighbors` constructs a KNN graph based on the euclidean distance in PCA space and refines the edge weights between any two cells based on the shared overlap in their local neighborhoods (Jaccard similarity). The next step is `FindClusters`, where we apply the Louvain algorithm to iteratively group cells together, with the goal of optimizing the standard modularity function. 

After we have grouped the cells, we might want to ask questions about the clusters -- for example, are there differentially expressed genes across clusters? **This gets us into 'double-dipping' territory.** We have clustered the cells based on their gene expression and then want to ask questions about which genes are differentially expressed across those groups. We are generating hypotheses based on the data and then testing the hypotheses on the same data. This can lead to an uncontrolled type I error rate when using classical hypothesis tests like the Wilcoxon test. 

We can use a program called `clusterpval` to check whether the difference in means of the clusters is significant. [@Gao2021] This is meant to partially address the problem of "double dipping," where the same data used to cluster and thus form groups is then used again for post-clustering analysis with the clusters designated as the groups. The method adjusts the pvalue for difference in means of the clusters. However it does not adjust pvalues for differential expression analysis, or difference in means of a subset of the data (i.e. genes), which would be what we actually want to do. Nevertheless it can be used as a check on the validity of the clusters.

We follow the code from [issue#2](https://github.com/lucylgao/clusterpval/issues/2) on the `clusterpval` repo. They are working on an [implementation for expression analysis](https://github.com/lucylgao/clusterpval/issues/3). Unfortunately the code isn't parallelized so it takes a while to run even with 100 draws, (was not willing to try 1000) but the pvalues returned are NaN (with a test statistic of around 17) so cluster 2 is likely real. It is also the most distinct cluster on the UMAP plots (Figure \@ref(fig:dimplot-reg)). My implementation of the clustering function also doesn't start from the counts matrix, it starts from the integrated data and just runs `FindClusters` with a different random seed each time, so that may impact results as well. Looking into this further can be a later individual question.



We can try working though running clusterpval. First, we will filter the pbmc3k data to keep it very small and then quickly run through normalization, clustering, and dimension reduction.


```{r}

pbmc3k
pbmc3k_sub <- subset(pbmc3k, subset = nFeature_RNA > 1000 & nFeature_RNA < 7000 )
pbmc3k_sub <- SCTransform(pbmc3k_sub,verbose=FALSE)
pbmc3k_sub <- RunPCA(pbmc3k_sub)
pbmc3k_sub <- FindNeighbors(pbmc3k_sub, dims = 1:8)
pbmc3k_sub <- FindClusters(pbmc3k_sub)
pbmc3k_sub <- RunUMAP(pbmc3k_sub, dims = 1:8)
pbmc3k_sub <- RunTSNE(pbmc3k_sub, tsne.method = "FIt-SNE", seed.use=61)
DimPlot(pbmc3k_sub, label = TRUE)

```

Then we can run clusterpval. Let's get out the clusters:

```{r}
clusters <-pbmc3k_sub@meta.data[["seurat_clusters"]]
```

Set the default assay to be `RNA` (if you are working with an integrated dataset, use the `integrated` assay) and set a seed.
```{r}
DefaultAssay(pbmc3k_sub) <- "RNA"
```

clusterpval requires a clustering function as an argument. Here, we write out our clustering function, where we set a random seed, run `FindClusters`, and return the Seurat clusters.

```{r}
function_cluster <- function(x) {
    seed = sample.int(999999, size=1)
    tmp <- Seurat::FindClusters(pbmc3k_sub, random.seed=seed)
    return(tmp@meta.data[["seurat_clusters"]])
}
```

Here we can use the `test_clusters_approx` function and approximates the p-values for the clusters via importance sampling.
```{r, message=FALSE, warnings=FALSE, results='hide'}
tc <- test_clusters_approx(
  as.matrix(pbmc3k_sub@assays[["RNA"]]@counts),
  k1=1, k2=3, cl=clusters, cl_fun=function_cluster, ndraws=100)
```
```{r}
tc
```
The resulting output contains:
stat: the test statistic - the Euclidean distance between the mean of cluster k1 and the mean of cluster k2
pval: the approximate p-value
stderr: standard error of the p-value estimate
clusters: the estimated cluster assignments

We are getting back NaN for the pvalues, likely because we are using only 100 draws because we have limited time/oscar resources for the workshop.
The authors are working on an implementation for expression analysis what would allow this method to perform differential expression p-value correction, but it is not functional as yet (https://github.com/lucylgao/clusterpval/issues/3).

##############################

## Working with TransferAnchors from Seurat 
Seurat has a few built in methods to identify shared cell states present across different datasets. They can be different conditions, different individuals, technologies, etc. First, Seurat tries to find anchors between pairs of datasets. These represent pairwise correspondences between individual cells (one in each dataset), that Seurat hypothesizes originate from the same biological state. These ‘anchors’ are then used to harmonize the datasets, or transfer information from one dataset to another. In the first part of this workshop, we went over running data integration with SCTransform-normalized datasets from different experiments. In this follow up session, we will go over how you can leverage an integrated reference dataset to annotate new query datasets. This can be helpful for using cell atlases to annotate cell types in your experimental datasets.

We'll work with the `panc8` data.

```{r}
panc8
?panc8
```
First, lets split the object and run SCTransform

```{r}
pancreas.list <- SplitObject(panc8, split.by = "tech")
```

Then we run SCTransform
```{r}
pancreas.list <- lapply(pancreas.list, function(x) {
    x <- SCTransform(x,verbose=FALSE,return.only.var.genes = FALSE)}) 
```

To construct a reference, we will identify ‘anchors’ between the individual datasets. We'll pick 3 of the objects to construct our inegrated reference and 1 will be the query.
```{r}
pancreas.ref <- c(pancreas.list$celseq, pancreas.list$celseq2, pancreas.list$smartseq2)
pancreas.query <- pancreas.list$fluidigmc1
```

Then we can `SelectIntegrationFeatures`, `PrepSCTIntegration`, `FindIntegrationAnchors`, and `IntegrateData`.
```{r}
integration_features <- SelectIntegrationFeatures(pancreas.ref)
pancreas.ref <- PrepSCTIntegration(object.list = pancreas.ref, anchor.features = integration_features)
ref.anchors <- FindIntegrationAnchors(object.list = pancreas.ref , normalization.method = "SCT", anchor.features = integration_features)
pancreas.ref <- IntegrateData(anchorset = ref.anchors, normalization.method = "SCT")
```

Run PCA and UMAP
```{r}
pancreas.ref <- RunPCA(pancreas.ref, verbose = FALSE)
pancreas.ref <- RunUMAP(pancreas.ref, reduction = "pca", dims = 1:20, verbose = FALSE)

p1 <- DimPlot(pancreas.ref, reduction = "umap", split.by = "tech") & coord_fixed(ratio = 1)
p2 <- DimPlot(pancreas.ref, reduction = "umap", group.by = "celltype", label = TRUE, repel = TRUE) +
    NoLegend() & coord_fixed(ratio = 1)
p1 / p2
```


Seurat also supports the projection of reference data (or meta data) onto a query object. While many of the methods are conserved (both procedures begin by identifying anchors), there are two important distinctions between data transfer and integration:

    In data transfer, Seurat does not correct or modify the query expression data.
    In data transfer, Seurat has an option (set by default) to project the PCA structure of a reference onto the query, instead of learning a joint structure with CCA. We generally suggest using this option when projecting data between scRNA-seq datasets.

After finding anchors, we use the `TransferData()` function to classify the query cells based on reference data (a vector of reference cell type labels). `TransferData()` returns a matrix with predicted IDs and prediction scores, which we can add to the query metadata.

First, FindTransferAnchors between pancreas.ref and pancreas.query.
```{r}
pancreas.anchors <- FindTransferAnchors(reference = pancreas.ref, 
                                        query = pancreas.query,
                                        dims = 1:20, 
                                        reference.reduction = "pca")
```

Classify query cells based on reference data
```{r}
predictions <- TransferData(anchorset = pancreas.anchors, 
                            refdata = pancreas.ref$celltype,
                            dims = 1:20)
```

Add the cell predictions to the pancreas.query metadata
```{r}
pancreas.query <- AddMetaData(pancreas.query, metadata = predictions)
```

Because we have the original label annotations from our full integrated analysis, we can evaluate how well our predicted cell type annotations match the full reference. In this example, we find that there is a high agreement in cell type classification, with over 96% of cells being labeled correctly.
```{r}
pancreas.query$prediction.match <- pancreas.query$predicted.id == pancreas.query$celltype
table(pancreas.query$prediction.match)
```

##############################

## Gene set enrichment analysis

Gene set enrichment analysis attempts to identify genes that are over-represented in a set of genes that make up pathways associated with various mechanisms. You can think of it like this: if a particular pathway consists of 300 genes, and 280 of those 300 genes are in our list of differentially expressed genes, then is that pathway relevant to the differences between our groups of interest?

Two commonly used methods to look for enrichment are overrepresentation analysis (ORA) or gene set enrichment analysis (GSEA). 
- Over Representation Analysis (ORA) looks for functions or processes that are over-represented (= enriched) in an experimentally-derived gene list (e.g. all differentially expressed genes) relative to a background gene list (e.g. all genes in the dataset) (https://academic.oup.com/bioinformatics/article/20/18/3710/202612?login=true). 
- Gene Set Enrichment (GSEA) takes a ranked list of genes (e.g. all genes in the differential expression analysis sorted by log fold change or test statistic or some other metric) and calculates an enrichment score based on whether a gene set is over-represented at the top or bottom of the list (https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1239896/).

ORA will miss smaller but coordinated changes in pathways -- so, when a pathway doesn't contain many differentially expressed genes, but all the genes in the pathway change together.

Here we'll talk about some GSEA methods you can use with your single cell data. Some of the details of the implementation can vary, but the core results some such analyses are:

    Enrichment score (ES) - a representation of how overrepresented a gene set is at the top or bottom of the ranked list.
    p-value of ES - the significance of the score for that gene set
    Adjusted p-value - an adjusted p-value to account for multiple hypothesis testing of multiple gene sets

Let's try running some GSEA analyses on the `ifnb` data. Let's run through the standard data processing pipeline and run `FindMarkers` to compare `STIM` to `CTRL`.

```{r}
ifnb_sub <- subset(ifnb, subset = nFeature_RNA > 1000 & nFeature_RNA < 7000 )
ifnb.list <- SplitObject(ifnb_sub, split.by = 'stim')
ifnb.list <- lapply(ifnb.list, function(x) {
    x <- SCTransform(x,verbose=FALSE,return.only.var.genes = FALSE)})
ifnb.merge <- merge(x = ifnb.list$CTRL, y = ifnb.list$STIM, merge.data = TRUE) 
integration_features <- SelectIntegrationFeatures(ifnb.list)
VariableFeatures(ifnb.merge) <- integration_features
ifnb.merge <- RunPCA(ifnb.merge)
ElbowPlot(ifnb.merge)
```

```{r}
ifnb.list <- PrepSCTIntegration(object.list = ifnb.list, anchor.features = integration_features)
ifnb.anchors <- FindIntegrationAnchors(object.list = ifnb.list, normalization.method = "SCT", anchor.features = integration_features)
ifnb_integrated <- IntegrateData(anchorset = ifnb.anchors, normalization.method = "SCT")
ifnb_integrated <- RunPCA(ifnb_integrated)
ifnb_integrated<- FindNeighbors(ifnb_integrated, dims = 1:10)
ifnb_integrated <- FindClusters(ifnb_integrated)
ifnb_integrated <- RunUMAP(ifnb_integrated, dims = 1:10)
ifnb_integrated <- RunTSNE(ifnb_integrated, tsne.method = "FIt-SNE", seed.use=61)
```
```{r}
DefaultAssay(ifnb_integrated) <- 'RNA'
Idents(ifnb_integrated) <- 'stim'

ctl_vs_stim <- FindMarkers(ifnb_integrated, ident.1 = 'CTRL', ident.2 = 'STIM', min.pct = 0.95, logfc.threshold = log(2))
ctl_vs_stim$zscore <- qnorm(ctl_vs_stim$p_val/2.0, lower.tail=FALSE)
ctl_vs_stim$se <- abs(ctl_vs_stim$avg_log2FC/ctl_vs_stim$zscore)
ctl_vs_stim$beta_var <- ctl_vs_stim$se^2
#from https://github.com/xzhoulab/iDEA/issues/4
```

#pick this gene set https://www.gsea-msigdb.org/gsea/msigdb/cards/REACTOME_INTERFERON_SIGNALING


all_gene_sets <- msigdbr()


Idents(sct.combined) <- "seurat_clusters"
wt_vs_mut_null <- FindMarkers(sct.combined, ident.1 = "WT", ident.2 = "MUT",
                       group.by="treatment", subset.ident="2", test.use="MAST")
sum_wt_vs_mut_null <- stderr(wt_vs_mut_null)


We also run a more standard GSEA analysis, on just the Hallmark gene sets. There is an open question of how to create a ranked list for this analysis. We started with avg_logFC as was suggested in issue#50 on the fgsea repo, but it returned no significant pathways at all, which does not seem right for our comparisons also given Table \@ref(tab:de-markers). This may be because in the discussion avg_logFC was suggested when comparing markers just between cell type clusters, but we are also actually comparing between different treatment types. Another option was to use -sign(avg_log2FC)*log10(p_val_adj), which incorporates both logfoldchange and the pvalue. This approach seemed more reasonable and yielded results more similar to iDEA.
iDEA

GSEA and ORA are dependent on an initial differential expression analysis. However, the differential expression of an individual gene also has an obvious dependence on gene set enrichment, as gene sets contain information about the individual genes within the set. iDEA (integrative Differental expression and gene set Enrichment Analysis) addresses this joint dependence through a model that jointly estimates both differential expression and gene set enrichment. The input to this method is still a list of per-gene summary statistics from an initial differential expression analysis, but iDEA has increased power and provides updated results for detection of both differentially expressed genes and gene sets.
notes for brainstorming

    Show how to pull out hallmark gene sets (or any) with msigdbr
    Show how to get markers with necessary options to get all genes
    Show how to compute number of DE genes out of total
    Show how to do an ORA with hypergeometric distribution
    Show how to do an ORA with ClusterProfiler
    Show how to make ranked list with log2FC and -sign(log2FC)xlog10(pval) for GSEA with fgsea and compare
    Show how to make summary statistics list with iDEA
    graphic for iDEA
    Don't run iDEA but show code


```{r "multimodal things go here"}

```


