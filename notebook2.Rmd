# Advanced Topics in scRNAseq 
What we'll cover:
    - Working with multimodal data
    - Controlling for Type I error in estimated clusters with clusterpval
    - Classifying cell types with a reference atlas with TransferAnchors from Seurat    
    - Gene set enrichment analysis with fgsea
    - Joint estimation of differential expression and gene set enrichment with iDEA      
    
### Working with multimodal data
Multimodal scRNA-seq is a quickly evolving field that allows simultaneous measurements of multiple types of information from a given cell. We won't discuss these exhaustively, but will briefly cover CITE-seq, cell hashing, and the 10x ATAC + GEX Multiome kits.

**CITE-seq and Cell Hashing**
This workshop will touch on working with CITE-seq data, which simultaneously profiles cell surface protein and gene expression levels (https://www.nature.com/articles/nmeth.4380 and https://cite-seq.com/). 

![sc flow](src/citeseq_flow.png)
Similar to the standard set-up for 10x gene expression preps, CITE-seq starts with a cell and a barcoded bead encapsulated in a droplet. However, before the encapsulation step, oligo-barcoded antibodies are added to the cells and will bind to the cell surface proteins. 
   
![sc flow](src/citeseq_str.png)

The oligo-tagged antibodies look like the above figure. Once the cells are in a droplet with a bead, the bead dissolves and the poly(dT) primer will allow amplification of both the poly-adenylated mRNA and the antibody barcode library. The two cDNA pools are size-separated before library prep continues, so you'll get back a quantitative gene expression and quantitative antibody derived tag (ADT) library. The authors of CITE-seq state: "We have successfully used ~125 antibodies and do not foresee any reason why this number can’t be further increased", but as always this is dependent on the quality of your antibodies. CellRanger/10X don't formally support CITE-seq for their own reasons and suggest you contact New York Genome Center/https://cite-seq.com/ or BioLegend for help (https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/using/feature-bc-analysis#feature-ref).

![sc flow](src/cellhashing.png)

Cell hashing is similar to CITE-seq, but the goal is to pool multiple samples per 10x run rather than to quantify cell surface proteins. It still uses oligo-tagged antibodies, but they target a smaller subset of cell surface proteins that are ubiquitously expressed and each sample has a unique oligo sequence that can be used to bin each cell back to the sample it originated from. A cell hashing experiment would result in an HTO library (HashTag Oligo) and a gene expression library.

![sc flow](src/totalseq.png){height=400px width=300px} 

BioLegend cells TotalSeq kits to run cell hashing experiments. TotalSeq-B and TotalSeq-C are supported by 10x and they use Capture Sequence 1 or the Template Switch Oligo as the capture sequence. Like CITE-seq, TotalSeq-A uses the Poly(dT) capture sequence and is not supported by 10x and they suggest you contact New York Genome Center/https://cite-seq.com/ or BioLegend for help.

**10X Multiome kit**

![sc flow](src/atac_bead.png){height=175px width=500px} 

The 10x Multiome ATAC + GEX kits let you look at areas of open chromatin and gene expression at the same time. They use a similar approach to the others described above, where a gel bead has primers/capture sequences for gene expression libraries and ATAC-seq libraries. The general workflow starts with isolating single nuclei (rather than single cells). Then, single nuclei are treated with a transposase that fragments DNA in open chromatin areas and adds adapter sequences to the ends of the fragments. The gel beads contain the usual Poly(dT) to amplify poly-adenylated mRNA and also a 'Spacer' sequence that acts as a capture sequence for the ATAC-seq libraries that sequence areas of open chromatin. 

###############################################

Let's try working with some multimodal data in Seurat.

As in the previous workshop, we'll need to set the `.libPaths()`, set a seed and `future.globals.maxSize`, and import the libraries.

```{r}
.libPaths(c('/usr/local/lib/R/site-library', '/usr/local/lib/R/library'))
set.seed(61)
options(future.globals.maxSize = 4000 * 1024^5)
library(RColorBrewer)
library(Seurat)
library(patchwork)
library(ggplot2)
library(dplyr)
library(hdf5r)
library(stringr)
library(biomaRt)
library(kableExtra)
library(knitr)
library(pdftools)
library(viridis)
library(openxlsx)
library(SeuratDisk)
library(SeuratData)
library(ComplexHeatmap)
library(plotly)
library(iDEA)
library(fgsea)
library(clusterpval)
library('pbmc3k.SeuratData')
library('cbmc.SeuratData')
library('ifnb.SeuratData')
data("pbmc3k")
data("cbmc")
data("ifnb")
cbmc

```

We'll work with the `cbmc` data for this section of the workshop, which is 8,617 cord blood mononuclear cells (CBMCs), produced with CITE-seq 
```{r}
cbmc
```

- This data has already come with the ADT assay added, which you'd have to add on your own if you were working with your own data.
- To do that, you'd use the `Read10x` or `Read10X_h5` functions to import your GE and ADT libraries. 
- At this point you might want to do some filtering on your data to get back cell barcodes where you've got RNA and ADT data.
- That might look like this (I've commented out the code here since it won't actually run, you can see the Seurat vignette here https://satijalab.org/seurat/articles/hashing_vignette.html, which shows how to demultiplex cell hashing data):

First, read in the 10X data
```{r}
#pbmc.ge <- Read10X("/pbmc_ge/outs/filtered_feature_bc_matrix")
#pbmc.adt <- Read10X("/pbmc_adt/outs/filtered_feature_bc_matrix")
```

Then, find the column names (which are cells) where you have data from both assays
```{r}
#joint.bcs <- intersect(colnames(pbmc.ge), colnames(pbmc.adt))
```

Then subset counts by joint cell barcodes
```{r}
#pbmc.ge <- pbmc.ge[, joint.bcs]
#pbmc.adt <- pbmc.adt[, joint.bcs]
```

Then you'd use the `CreateSeuratObject` function with the gene expression matrix.
```{r}
#pbmc_seurat <- CreateSeuratObject(counts = pbmc.ge)
```

Then add the ADT data as an assay:
```{r}
#pbmc_seurat[["ADT"]] <- CreateAssayObject(counts = pbmc.adt)
```

Let's look at the multimodal seurat object assays:    

For the RNA assay, cells are columns and rows are genes.
```{r}
head(rownames(cbmc@assays$RNA))
head(colnames(cbmc@assays$RNA))
```

For ADT assay, cells columns and rows are cell surface proteins.
```{r}
rownames(cbmc@assays$ADT)
head(colnames(cbmc@assays$ADT))
```

Make sure the RNA is the default assay:
```{r}
DefaultAssay(cbmc) <- 'RNA'
```

We can run through the standard data normalization, clustering, and dimension reduction pipeline, skipping the QC filtering since this is a curated dataset.
```{r}
# perform visualization and clustering steps
cbmc <- SCTransform(cbmc,verbose=FALSE,return.only.var.genes = FALSE)
cbmc <- RunPCA(cbmc, verbose = FALSE)
cbmc <- FindNeighbors(cbmc, dims = 1:10)
cbmc <- FindClusters(cbmc)
cbmc <- RunUMAP(cbmc, dims = 1:10)
cbmc <- RunTSNE(cbmc, tsne.method = "FIt-SNE", seed.use=61)
DimPlot(cbmc, label = TRUE)
```

We'll also normalize the CITE-seq ADT dat. We'll use a CLR or centered log ratio transformation. 
```{r}
DefaultAssay(cbmc) <- "ADT"
cbmc <- NormalizeData(cbmc, normalization.method = "CLR")
```

Then we can visualize our data -- let's look at the CD19 RNA and Protein expression:
```{r}
DefaultAssay(cbmc) <- "RNA"
p1 <- FeaturePlot(cbmc, 
            features = "CD19", 
            reduction = 'umap',  
            order = T) &
    theme(legend.position = "right") &
    scale_colour_gradient(low = '#67a9cf', high = '#ef8a62') &
    labs(title = "RNA - CD19")

DefaultAssay(cbmc) <- "ADT"
p2 <- FeaturePlot(cbmc, 
            features = "CD19", 
            reduction = 'umap',  
            order = T) &
    theme(legend.position = "right") &
    scale_colour_gradient(low = '#67a9cf', high = '#ef8a62') &
    labs(title = "ADT - CD19")


p1 | p2
```

We can leverage the multimodal data to find protein and RNA markers

First, which clusters of cells are expressing CD19 on their cell surfaces?
```{r}
VlnPlot(cbmc, "CD19", assay = "ADT")
```

Let's look at the ADT markers for cluster 10. You can use the same `FindMarkers` functions that are used for RNA markers.
```{r}
adt_markers <- FindMarkers(cbmc, ident.1 = 10, assay = "ADT")
rna_markers <- FindMarkers(cbmc, ident.1 = 10, assay = "RNA")
```

```{r}
head(rna_markers)
head(adt_markers)
```

Let's clear the `cbmc` data before we move on.

```{r}
rm(cbmc)
```


### Controlling for Type I error in estimated clusters with clusterpval
The first part of this workshop ran through how to use Seurat to cluster the cells. The first step is running a PCA (`RunPCA`), which then gets used as the input for the `FindNeighbors` function. `FindNeighbors` constructs a KNN graph based on the euclidean distance in PCA space and refines the edge weights between any two cells based on the shared overlap in their local neighborhoods (Jaccard similarity). The next step is `FindClusters`, where we apply the Louvain algorithm to iteratively group cells together, with the goal of optimizing the standard modularity function. 

After we have grouped the cells, we might want to ask questions about the clusters -- for example, are there differentially expressed genes across clusters? **This gets us into 'double-dipping' territory.** We have clustered the cells based on their gene expression and then want to ask questions about which genes are differentially expressed across those groups. We are generating hypotheses based on the data and then testing the hypotheses on the same data. This can lead to an uncontrolled type I error rate when using classical hypothesis tests like the Wilcoxon test. 

We can use a program called `clusterpval` to check whether the difference in means of the clusters is significant. [@Gao2021] This is meant to partially address the problem of "double dipping," where the same data used to cluster and thus form groups is then used again for post-clustering analysis with the clusters designated as the groups. The method adjusts the pvalue for difference in means of the clusters. However it does not adjust pvalues for differential expression analysis, or difference in means of a subset of the data (i.e. genes), which would be what we actually want to do. Nevertheless it can be used as a check on the validity of the clusters.

We follow the code from [issue#2](https://github.com/lucylgao/clusterpval/issues/2) on the `clusterpval` repo. They are working on an [implementation for expression analysis](https://github.com/lucylgao/clusterpval/issues/3). Unfortunately the code isn't parallelized so it takes a while to run even with 100 draws, (was not willing to try 1000) but the pvalues returned are NaN (with a test statistic of around 17) so cluster 2 is likely real. It is also the most distinct cluster on the UMAP plots (Figure \@ref(fig:dimplot-reg)). My implementation of the clustering function also doesn't start from the counts matrix, it starts from the integrated data and just runs `FindClusters` with a different random seed each time, so that may impact results as well. Looking into this further can be a later individual question.



We can try working though running clusterpval. First, we will filter the pbmc3k data to keep it very small and then quickly run through normalization, clustering, and dimension reduction.


```{r}

pbmc3k
pbmc3k_sub <- subset(pbmc3k, subset = nFeature_RNA > 1000 & nFeature_RNA < 7000 )
pbmc3k_sub <- SCTransform(pbmc3k_sub,verbose=FALSE)
pbmc3k_sub <- RunPCA(pbmc3k_sub)
pbmc3k_sub <- FindNeighbors(pbmc3k_sub, dims = 1:8)
pbmc3k_sub <- FindClusters(pbmc3k_sub)
pbmc3k_sub <- RunUMAP(pbmc3k_sub, dims = 1:8)
pbmc3k_sub <- RunTSNE(pbmc3k_sub, tsne.method = "FIt-SNE", seed.use=61)
DimPlot(pbmc3k_sub, label = TRUE)

```

Then we can run clusterpval. Let's get out the clusters:

```{r}
clusters <-pbmc3k_sub@meta.data[["seurat_clusters"]]
```

Set the default assay to be `RNA` (if you are working with an integrated dataset, use the `integrated` assay) and set a seed.
```{r}
DefaultAssay(pbmc3k_sub) <- "RNA"
```

clusterpval requires a clustering function as an argument. Here, we write out our clustering function, where we set a random seed, run `FindClusters`, and return the Seurat clusters.

```{r}
function_cluster <- function(x) {
    seed = sample.int(999999, size=1)
    tmp <- Seurat::FindClusters(pbmc3k_sub, random.seed=seed)
    return(tmp@meta.data[["seurat_clusters"]])
}
```

Here we can use the `test_clusters_approx` function and approximates the p-values for the clusters via importance sampling.
```{r}
tc <- test_clusters_approx(
  as.matrix(pbmc3k_sub@assays[["RNA"]]@counts),
  k1=1, k2=7, cl=clusters, cl_fun=FindClusters, ndraws=100)
```

The resulting output contains:
stat: the test statistic - the Euclidean distance between the mean of cluster k1 and the mean of cluster k2
pval: the approximate p-value
stderr: standard error of the p-value estimate
clusters: the estimated cluster assignments

We are getting back NaN for the pvalues, likely because we are using only 100 draws because we have limited time/oscar resources for the workshop.
The authors are working on an [implementation for expression analysis](https://github.com/lucylgao/clusterpval/issues/3), which we will continue to watch for.


## Working with TransferAnchors from Seurat 
See  (https://satijalab.org/seurat/archive/v3.0/integration.html) for an overview. Seurat has a few built in methods to identify shared cell states present across different datasets. They can be different conditions, different individuals, technologies, etc. First, Seurat tries to find anchors between pairs of datasets. These represent pairwise correspondences between individual cells (one in each dataset), that Seurat hypothesizes originate from the same biological state. These ‘anchors’ are then used to harmonize the datasets, or transfer information from one dataset to another. In the first part of this workshop, we went over running data integration wtih SCTransform-normalized datasets (https://satijalab.org/seurat/archive/v3.0/integration.html). In this follow up session, we will go over a similar approaches to integrate many datasets (https://satijalab.org/seurat/archive/v3.0/integration.html) or very large datasets (https://satijalab.org/seurat/archive/v3.0/integration.html).


## Gene set enrichment analysis
Gene set enrichment analysis attempts to identify genes that are over-represented in a set of genes that make up pathways associated with various mechanisms. You can think of it like this: if a particular pathway consists of 300 genes, and 280 of those 300 genes are in our list of differentially expressed genes (DEGs), then is that pathway relevant to the differences between our groups of interest?

One of the more basic approaches to answering this question is Overrepresentation Analysis (ORA) (citation: https://yulab-smu.top/biomedical-knowledge-mining-book/references.html#ref-boyle2004). It takes as input a list of genes (aka the background) with pvalues indicating which genes are differentially expressed, and a pathway / set of genes, computes the number of DEGs that are found in the pathway, and then computes a p-value using a hypergeometric distribution based on that number along with the number of background genes and number of genes in the pathway.
GSEA

ORA is solely based on the number of DEGs out of the , and thus will find pathways that have a lot of DEGs out of the background. However, ORA will miss smaller but coordinated changes in pathways, for example when a pathway does not contain many DEGs, but all genes in the pathway change together. A more complex approach to address this question is Gene Set Enrichment Analysis (GSEA), which utilizes all genes in the list rather than just the DEGs. GSEA takes a ranked list of genes in the set instead. How to create the ranked list is an open question, but typically log fold change, the test statistic, or a combination of log fold change and pvalue from a differential expression analysis are used.

We will not get into how GSEA method works here, but the core results from such an analysis are:

    Enrichment score (ES) - a representation of how overrepresented a gene set is at the top or bottom of the ranked list.
    p-value of ES - the significance of the score for that gene set
    Adjusted p-value - an adjusted p-value to account for multiple hypothesis testing of multiple gene sets

We also run a more standard GSEA analysis, on just the Hallmark gene sets. There is an open question of how to create a ranked list for this analysis. We started with avg_logFC as was suggested in issue#50 on the fgsea repo, but it returned no significant pathways at all, which does not seem right for our comparisons also given Table \@ref(tab:de-markers). This may be because in the discussion avg_logFC was suggested when comparing markers just between cell type clusters, but we are also actually comparing between different treatment types. Another option was to use -sign(avg_log2FC)*log10(p_val_adj), which incorporates both logfoldchange and the pvalue. This approach seemed more reasonable and yielded results more similar to iDEA.
iDEA

GSEA and ORA are dependent on an initial differential expression analysis. However, the differential expression of an individual gene also has an obvious dependence on gene set enrichment, as gene sets contain information about the individual genes within the set. iDEA (integrative Differental expression and gene set Enrichment Analysis) addresses this joint dependence through a model that jointly estimates both differential expression and gene set enrichment. The input to this method is still a list of per-gene summary statistics from an initial differential expression analysis, but iDEA has increased power and provides updated results for detection of both differentially expressed genes and gene sets.
notes for brainstorming

    Show how to pull out hallmark gene sets (or any) with msigdbr
    Show how to get markers with necessary options to get all genes
    Show how to compute number of DE genes out of total
    Show how to do an ORA with hypergeometric distribution
    Show how to do an ORA with ClusterProfiler
    Show how to make ranked list with log2FC and -sign(log2FC)xlog10(pval) for GSEA with fgsea and compare
    Show how to make summary statistics list with iDEA
    graphic for iDEA
    Don't run iDEA but show code


```{r "multimodal things go here"}

```



```{r}
data_dir <- '/gpfs/data/cbc/scrna_r_workshop'
pbmc.1k <- Read10X_h5(paste0(data_dir, '/data/pbmc_1k_v3_filtered_feature_bc_matrix.h5'))
pbmc.5k <- Read10X_h5(paste0(data_dir, '/data/5k_pbmc_v3_filtered_feature_bc_matrix.h5'))
pbmc.1k <- CreateSeuratObject(counts = pbmc.1k, project = 'pbmc.1k')
pbmc.5k <- CreateSeuratObject(counts = pbmc.5k, project = 'pbmc.5k')

all_data <- merge(x = pbmc.1k, y = c(pbmc.5k), project = 'pbmc')
all_data[["percent.mt"]] <- PercentageFeatureSet(all_data, pattern = "^MT-")
all_data_sub <- subset(all_data, subset = nFeature_RNA > 500 & nFeature_RNA < 6000 & percent.mt < 25)
all_data_split <- SplitObject(all_data_sub, split.by = 'orig.ident')
all_data_list <- lapply(all_data_split, function(x) { x <- SCTransform(x,verbose=FALSE)}) # if you run this you might get several iteration limit reached issues

integration_features <- SelectIntegrationFeatures(all_data_list)
all_data_list <- PrepSCTIntegration(object.list = all_data_list, anchor.features = integration_features)
all_data_list <- lapply(X = all_data_list, FUN = RunPCA, features = integration_features)
anchors <- FindIntegrationAnchors(object.list = all_data_list, normalization.method = "SCT", anchor.features = integration_features)
all_data_integrated <- IntegrateData(anchorset = anchors, normalization.method = "SCT")

#test_hier_clusters_exact()
#test_clusters_approx()
```

In addition to clustering, you can use reference-mapping approaches to annotate cell types in a dataset.

In this example, we map our PBMC data to a CITE-seq reference of 162,000 PBMC measured with 228 antibodies (https://www.sciencedirect.com/science/article/pii/S0092867421005833?via%3Dihub). 


#https://satijalab.org/seurat/articles/multimodal_reference_mapping.html
#wget https://atlas.fredhutch.org/data/nygc/multimodal/pbmc_multimodal.h5seurat

Import the PBMC reference:

```{r}
reference <- LoadH5Seurat(paste0(data_dir,"/data/pbmc_multimodal.h5seurat"))
```

Loook at the metadata:
```{r}
head(reference@meta.data)
```
You can see that each cell has an 'orig.ident', which is a combination of 'donor' and 'time'.
You can also see different 'celltype' columns, where the cell types have been assigned at different levels (e.g., B, B memory, B memory kappa).

Look at the cell types
```{r}
DimPlot(object = reference, reduction = "wnn.umap", group.by = "celltype.l1", label = TRUE, label.size = 3, repel = TRUE) + NoLegend()
DimPlot(object = reference, reduction = "wnn.umap", group.by = "celltype.l3", label = TRUE, label.size = 3, repel = TRUE) + NoLegend()

```

We then find anchors between reference and query, the reference object has already been normalized using SCTransform (which we have also used on our query PBMCs):
The Seurat authors recommend the use of supervised PCA (spca) for CITE-seq datasets, but you can also use a standard PCA transformation.

```{r}
anchors <- FindTransferAnchors(
  reference = reference,
  query = all_data_integrated,
  normalization.method = "SCT",
  reference.reduction = "spca",
  dims = 1:50
)

```
We then transfer cell type labels and protein data from the reference to the query. Additionally, we project the query data onto the UMAP structure of the reference. MapQuery() is a wrapper around three functions: TransferData(), IntegrateEmbeddings(), and ProjectUMAP(). TransferData() is used to transfer cell type labels and impute the ADT ('antibody derived tag') values. IntegrateEmbeddings() and ProjectUMAP() are used to project the query data onto the UMAP structure of the reference. 


```{r}
all_data_integrated <- MapQuery(
  anchorset = anchors,
  query = all_data_integrated,
  reference = reference,
  refdata = list(
    celltype.l1 = "celltype.l1",
    celltype.l2 = "celltype.l2",
    predicted_ADT = "ADT"
  ),
  reference.reduction = "spca", 
  reduction.model = "wnn.umap"
)
```

The reference-mapped dataset helps us identify cell types. Let's look at  plasmacytoid dendritic cells (pDC) cells:

Each prediction is assigned a score between 0 and 1.

```{r}
FeaturePlot(all_data_integrated, features ="CD16 Mono",  reduction = "ref.umap", cols = c("lightgrey", "darkred"), ncol = 3) & theme(plot.title = element_text(size = 10))
```





*Gene Set Enrichment Analysis*
